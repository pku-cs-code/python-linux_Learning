python类和面向对象

面向过程
面向对象的三个特性：封装、继承、多态
 类
 子类
 父类
 多态
 实例
实例变量、成员变量self.name
实例本身
 把一个抽象的类变成一个具体的对象的过程叫做实例化

类变量、类属性
初始化
封装
继承

函数在类中叫方法,叫类的方法

类不能访问实例变量

把类方法变成静态方法，不能访问实例变量和类变量，和实例不能有关系了。
一般情况不用。可以作为类的一个工具箱
@property	可以访问实例变量和类变量，不能穿参数

私有属性self.__num
	其他语言是private static声明

经典类和新式类
  新式类加了若干方法
  底层实现不一样，多继承

广度优先
#!/usr/bin/env python
# -*- coding: utf-8 -*-

class A:
     n = 'A'
     def f2(self):
        print("f2 from A")
class B(A):
    n = 'B'
    def f1(self):
        print("from B")
    def f2(self):
        print("f2 from B")
class C(A):
    n = 'C'
    def f2(self):
        print("from C")
class D(B,C):
    pass

d = D()
d.f1()
d.f2()

d.f2先执行B的f2，然后B找不到就找C，C找不到找A
同一级别的找，找不到再往上走
广度优先跟深度优先不一样，如果按深度优先B没有就会去调用A的f2，这是不合理的
因为B和C处于同一级别，和d的关系更紧密

经典类是深度优先，新式类是广度优先

python3之后不管是经典类和新式类，都按新式类来实现


类的特殊成员
__doc__方法，类的介绍
__module__方法 模块所在文件的名字
__init__
__del__析构方法，实例在销毁的时候回自动执行这个方法，程序执行完统一销毁
	里面起什么作用自己规定，程序关闭时应用，一般不用。可以手动关闭
__call__比较底层，构造的执行是由创建对象触发的
__new__重新构造类，启动__init__的函数。重写了__new__之后，类本身改变了
__dict__以字典的形式显示类的变量，查看一个类有多少变量。不显示实例变量，只显示类变量
__getitem__
__setitem__
__delitme__
__getslice__
__setslice__
__delslice__
__iter__
__metaclass__最底层创建类的，一般涉及不到


type创造了类


