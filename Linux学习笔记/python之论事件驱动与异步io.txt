python之论事件驱动与异步io

事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是单线程同步及多线程编程。

select/poll/Epoll

select轮循事件，一个个去找
多平台支持
linux文件描述符默认1024，要想同时打开更多的文件可以修改用户的ulimit

操作系统
用户态，用户态
数组保存在内核态中
把整个数组复制到用户态中
复制事件呈线性增长
使大量tcp连接处于非活跃状态

poll修改了文件描述符限制，和select区别不是很大

poll和select将就绪的文件描述符告诉进程后，如果进程没有对其进行io操作，那么poll将再次报告这些文件描述符，称为水平触发

epoll
直到linux2.6内核直接支持
继续具备了之前所说的一切优点，公认为linux2.6下性能最好的多路i/o就绪通知方法
同时支持水平触发和边缘触发
边缘触发，只告诉一次，如果用户没处理，用户下次调用数据不再汇报，理论上性能会高一些，实际很少用

epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际描述符，而是代表就绪描述符的值，你只需要去epoll指定的一个数组一次取得相应数据描述符即可，这里也使用了内存映射(mmap)技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销

只返回少量活跃的数组，效率一下子高了很多

用户台无法访问内核态
内存映射，访问内存数据接口。通过用户句柄直接访问内存映射的接口，不用复制

另一个本质的改进在于epoll采用事件的就绪通知方式，在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于文件描述符就绪时，内核就会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()就会接收到数据，
操作系统在cpu处理数据后会将数据放在缓冲区，缓冲区满了之后就不接收数据了，客户端就阻塞了（os告知客户端不要发数据了，因为没地方装了）

单线程的，效率很高
最流行的多路io异步调用模型

python的select()方法直接调用操作系统的IO接口，它监控sockets，open files，and pipes（fileno()方法的文件句柄）何时变成readable和writeable，或者通信错误，select()使得同时监控多个连接变得简单，并且这比写一个长循环来等待和监控多客户端连接要高效，因为select直接通过操作系统提供的c的网络接口进行操作而不是Python的解释器。
注意：using python's file objects with select() works for unix, but is not supported under windows.
select好像支持windows



