python之算法简介

时间复杂度：在同一机器上运行的时间

语句频度或者时间频度，记为T(n)

ORDER(O) 时间复杂度函数

算法的基本操作重复执行的次数是模块n的某个函数f(n)，因此，算法的时间复杂度记做
T(n)=O(f(n))，随着模块n的增大，算法执行的时间的增长率和f(n)的增长率成正比，所以f(n)
越小，算法的时间复杂度越低，算法的效率越高

T Time
n是问题的规模
n趋近于无穷大，T(n)和f(n)的比值为不为零的常数

常数时间，例如给定数组，知道数组下标就可以直接找到那个数，而不用管数组的总大小是多少的

对数时间
T(n) = O(log(n))

线性时间
O(n)

效率logn>nlogn>n^2

尽量控制在o(n^2)

冒泡排序
选择排序

冒泡排序5000次循环，100000以内的数花时间7.6   7.59秒
选择排序5000次循环，100000以内的数花时间6.14  6.06秒 
	优化后的选择排序时间更少 3.59   3.57秒  因为不用每次都交换
插入排序5000次循环，100000以内的数花时间 4.56 4.29秒 
时间复杂度都是O(n^2)


快速排序5000次循环，100000以内的数花时间 0.04 0.04秒 最好的复杂度是logn，最坏的复杂度是O(n^2),大多情况是logn


二叉树
数：非线性的数据结构
数是元素的集合
没有子节点的节点称为叶子节点
深度

递归定义：树
1、树是元素的集合
2、该集合可以为空，这时树中没有元素，我们称为空树
3、如果该集合不为空，那么该集合有一个根节点，以及0个或者多个子树，根节点和它的子树的根节点用一个边（edge）相连

二叉树：
每个节点最多只能有两个子节点
1）二叉树是有序树，即使只有一个子树，也必须区分左右子树
2）二叉树的每个节点的度不能大于2，只能取0、1、2三者之一
3）二叉树中所有节点的的形态有五种：空节点、无左右子树的节点、只有左子树的节点、只有右子树的节点和具有左右子树的节点

左子节点是左子树根的节点，右子节点是右子树的根节点

二叉搜索树需要二叉树再加一个条件：每个节点都不比它左子树的任意元素小，而且不比它的右子树等待任意元素大

如果数中没有重复的元素，那么每个节点比右边子树的任意节点小，比左边的任意节点大

搜索次数不可能超过层数

遍历二叉树
前序遍历  根节点->左子树->右子树
中序遍历  左子树->根节点->右子树
后序遍历  左子树->右子树->根节点


完全二叉树
高度为h，除第h层外，其他各层的节点数都达到最大个数

满二叉树
除了叶子节点外每一个节点都有左右子叶且子节点都处在最底层的二叉树

平衡二叉树（AVL树）
它是一棵树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树
红黑树是平衡二叉树的一种

堆排序
堆：一种数据结构
最大堆（大顶堆）节点元素大于其孩子
最小堆（小顶堆）节点元素小于其孩子
是完全二叉树

现实中python用类存数据比较浪费空间
把堆改成列表的形式

先构建一个大顶堆










	
	






